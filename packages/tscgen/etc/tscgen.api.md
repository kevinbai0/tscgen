## API Report File for "tscgen"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public (undocumented)
export function arrayType<T extends IType>(type: T, ...extract: ITypePropertyType[]): IArrayType<T>;

// Warning: (ae-forgotten-export) The symbol "IJsValue" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "IJsArrayValue" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export function arrayValue(...values: IJsValue[]): IJsArrayValue;

// Warning: (ae-forgotten-export) The symbol "BooleanLiterals" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export function booleanTuple<T extends Readonly<boolean[]>>(...type: T): ITupleType<BooleanLiterals<T>>;

// @public (undocumented)
export function booleanType(): IBooleanType;

// @public (undocumented)
export function booleanType<T extends boolean[]>(...value: T): IUnionType<BooleanLiterals<T>>;

// Warning: (ae-forgotten-export) The symbol "IImportModuleType" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type BuildersToImport<T> = {
    [Key in keyof T]: T[Key] extends IBaseBuilder<IBaseBuilderTypes, string> ? IImportModuleType<T[Key]> : never;
};

// @public (undocumented)
export function combine(...builders: IBaseBuilder<IBaseBuilderTypes, string>[]): string;

// @public (undocumented)
export const createFormatter: (pathToFile: string) => (text: string) => Promise<string>;

// Warning: (ae-forgotten-export) The symbol "GetInputs" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export const createInputsExport: <T>(method: GetInputs<T>) => GetInputs<T>;

// Warning: (ae-forgotten-export) The symbol "GetMappedExports" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export const createMappedExports: <Inputs extends GetInputs<any>, Builders extends readonly IBaseBuilder<IBaseBuilderTypes, string>[]>(_inputs: Inputs, getBuilders: GetMappedExports<Inputs, Builders, false>) => GetMappedExports<Inputs, Builders, false>;

// @public (undocumented)
export const createPathExport: (dir: string, filename: string) => [dir: string, filename: string];

// Warning: (ae-forgotten-export) The symbol "GetStaticExports" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export const createStaticExports: <Builders extends readonly IBaseBuilder<IBaseBuilderTypes, string>[]>(getBuilders: () => Promise<[...Builders]>) => GetStaticExports<Builders>;

// @public (undocumented)
export function extract<T extends IType, K extends Readonly<IType[]>, U extends IUnionType<K>>(type: T, union: U): IDecorationType<[T, U]>;

// @public (undocumented)
export function genericType<T extends string>(value: T): IGenericIdentifierType<T>;

// Warning: (ae-forgotten-export) The symbol "OutputModule" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "IReference" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export function getReference<Inputs extends GetInputs, MappedBuilders extends ReadonlyArray<IBaseBuilder<'interface' | 'type', string>>, StaticBuilders extends ReadonlyArray<IBaseBuilder<'interface' | 'type', string>>>(importFile: Promise<OutputModule<Inputs, MappedBuilders, StaticBuilders>>, callerPath: string): Promise<IReference<Inputs, MappedBuilders, StaticBuilders>>;

// @public (undocumented)
export interface IArrayType<T extends IType = IType> {
    // (undocumented)
    definition: T;
    // (undocumented)
    extract?: ITypePropertyType[];
    // (undocumented)
    type: 'array';
}

// @public (undocumented)
export interface IBaseBuilder<Type extends IBaseBuilderTypes, Name extends string> {
    // (undocumented)
    markExport(): IBaseBuilder<Type, Name>;
    // (undocumented)
    toString(): string;
    // (undocumented)
    type: Type;
    // (undocumented)
    varName: Name;
}

// @public (undocumented)
export type IBaseBuilderTypes = 'type' | 'interface' | 'object' | 'import';

// @public (undocumented)
export interface IBodyType {
    // (undocumented)
    [key: string]: IType | [IType, boolean];
}

// @public (undocumented)
export interface IBooleanLiteralType<T extends boolean = boolean> {
    // (undocumented)
    definition: T;
    // (undocumented)
    type: 'boolean_literal';
}

// @public (undocumented)
export interface IBooleanType {
    // (undocumented)
    type: 'boolean';
}

// @public (undocumented)
export interface IDecorationType<T extends Readonly<IType[]> = Readonly<IType[]>> {
    // (undocumented)
    decorate: (...value: string[]) => string;
    // (undocumented)
    definition: T;
    // (undocumented)
    type: 'decoration';
}

// @public (undocumented)
export function identifierType<T extends IBaseBuilder<'type' | 'interface', string>>(builder: T, ...extract: ITypePropertyType[]): IIdentifierType;

// Warning: (ae-forgotten-export) The symbol "IJsIdentifierValue" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export function identifierValue<Type extends IBaseBuilderTypes, Name extends string>(builder: IBaseBuilder<Type, Name>): IJsIdentifierValue;

// @public (undocumented)
export type IGenericIdentifierType<T extends string = string> = {
    type: 'generic_identifier';
    definition: T;
};

// @public (undocumented)
export type IGenericOptions = {
    extendsValue?: IType;
    defaultValue?: IType;
} | undefined;

// @public (undocumented)
export type IGenericValue<Name extends string = string, Options extends IGenericOptions = undefined> = {
    name: Name;
    options: Options;
};

// @public (undocumented)
export interface IIdentifierType<T extends IBaseBuilder<'type' | 'interface', string> = IBaseBuilder<'type' | 'interface', string>> {
    // (undocumented)
    definition: T;
    // (undocumented)
    extract?: ITypePropertyType[];
    // (undocumented)
    type: 'identifier';
}

// @public (undocumented)
export interface IImportBuilder<Module extends ReadonlyArray<IImportModuleType>, AllModules extends string | undefined, DefaultImport extends string | undefined, Location extends string | undefined> extends IBaseBuilder<'import', string> {
    // (undocumented)
    addAllModuleImports: <T extends string>(name: T) => IImportBuilder<Module, T, DefaultImport, Location>;
    // (undocumented)
    addDefaultImport: <T extends string>(name: T) => IImportBuilder<Module, AllModules, T, Location>;
    // (undocumented)
    addImportLocation: <T extends string>(name: T) => IImportBuilder<Module, AllModules, DefaultImport, T>;
    // (undocumented)
    addModules: <T extends ReadonlyArray<IBaseBuilder<IBaseBuilderTypes, string>>>(...builder: T) => IImportBuilder<[
        ...Module,
        ...BuildersToImport<T>
    ], AllModules, DefaultImport, Location>;
    // (undocumented)
    type: 'import';
}

// @public (undocumented)
export interface IInterfaceBuilder<Name extends string, Generics extends Readonly<IGenericValue<string, IGenericOptions | undefined>[]>, Body extends IBodyType, Exported extends boolean, Extend extends IIdentifierType<IBaseBuilder<'interface', string>> | undefined> extends IBaseBuilder<'interface', Name> {
    // Warning: (ae-forgotten-export) The symbol "Combine" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    addBody<T extends IBodyType>(body: T): IInterfaceBuilder<Name, Generics, Combine<Body, T>, Exported, Extend>;
    // (undocumented)
    addGeneric<N extends string, Options extends IGenericOptions = {}, T extends Readonly<IGenericValue<N, Options>> = Readonly<IGenericValue<N, Options>>>(name: N, options?: Options): IInterfaceBuilder<Name, [...Generics, T], Body, Exported, Extend>;
    // (undocumented)
    body: Body;
    // (undocumented)
    extends<T extends IBaseBuilder<'interface', string>>(type: T): IInterfaceBuilder<Name, Generics, Body, Exported, IIdentifierType<T>>;
    // (undocumented)
    generics: Generics;
    // (undocumented)
    markExport(): IInterfaceBuilder<Name, Generics, Body, true, Extend>;
    // (undocumented)
    type: 'interface';
}

// @public (undocumented)
export function importBuilder<Module extends ReadonlyArray<IImportModuleType> = [], AllModules extends string | undefined = undefined, DefaultImport extends string | undefined = undefined, Location extends string | undefined = undefined>(defaultOptions?: {
    modules: ReadonlyArray<IImportModuleType>;
    allModules?: AllModules;
    defaultImport?: DefaultImport;
    location?: Location;
}): IImportBuilder<Module, AllModules, DefaultImport, Location>;

// @public (undocumented)
export function interfaceBuilder<Name extends string, Generics extends Readonly<IGenericValue[]> = [], Body extends IBodyType = {}, Exported extends boolean = false, Extend extends IIdentifierType<IBaseBuilder<'interface', string>> | undefined = undefined>(interfaceName: Name, defaultOptions?: {
    generics?: Generics;
    extends?: Extend;
    body: Body;
    export: boolean;
}): IInterfaceBuilder<Name, Generics, Body, Exported, Extend>;

// @public (undocumented)
export interface INullType {
    // (undocumented)
    type: 'null';
}

// @public (undocumented)
export interface INumberLiteralType<T extends number = number> {
    // (undocumented)
    definition: T;
    // (undocumented)
    type: 'number_literal';
}

// @public (undocumented)
export interface INumberType {
    // (undocumented)
    type: 'number';
}

// @public (undocumented)
export type IObjectType<T extends IBodyType = IBodyType> = {
    type: 'object';
    definition: T;
    extract?: ITypePropertyType[];
};

// @public (undocumented)
export type IRawIdentifierType = {
    type: 'raw_identifier';
    definition: string;
};

// @public (undocumented)
export interface IRawTypePropertyType {
    // (undocumented)
    definition: string;
    // (undocumented)
    type: 'raw_property_type';
}

// @public (undocumented)
export interface IStringLiteralType<T extends string = string> {
    // (undocumented)
    definition: T;
    // (undocumented)
    type: 'string_literal';
}

// @public (undocumented)
export interface IStringType {
    // (undocumented)
    type: 'string';
}

// @public (undocumented)
export interface ITupleType<T extends ReadonlyArray<IType> = ReadonlyArray<IType>> {
    // (undocumented)
    definition: T;
    // (undocumented)
    extract?: ITypePropertyType[];
    // (undocumented)
    type: 'tuple';
}

// @public (undocumented)
export type IType<T extends any = any> = IStringType | INumberType | IBooleanType | IUndefinedType | INullType | IIdentifierType<T extends IBaseBuilder<'type' | 'interface', string> ? T : IBaseBuilder<'type' | 'interface', string>> | IArrayType<T extends IType ? T : IType> | IObjectType<T extends IBodyType ? T : IBodyType> | IUnionType<T extends Readonly<IType[]> ? T : Readonly<IType[]>> | IStringLiteralType<T extends string ? T : string> | INumberLiteralType<T extends number ? T : number> | IBooleanLiteralType<T extends boolean ? T : boolean> | ITupleType<T extends Readonly<IType[]> ? T : Readonly<IType[]>> | IDecorationType<T extends Readonly<IType[]> ? T : Readonly<IType[]>> | IGenericIdentifierType<T extends string ? T : string> | IRawIdentifierType;

// @public (undocumented)
export interface ITypeDefBuilder<Name extends string, Generics extends Readonly<IGenericValue<string, IGenericOptions>[]>, JoinedTypes extends ReadonlyArray<{
    type: IType;
    joinType: 'union' | 'intersection';
}>, Exported extends boolean> extends IBaseBuilder<'type', Name> {
    // (undocumented)
    addGeneric<N extends string, Options extends IGenericOptions = {}, T extends Readonly<IGenericValue<N, Options>> = Readonly<IGenericValue<N, Options>>>(name: N, options?: Options): ITypeDefBuilder<Name, [...Generics, T], JoinedTypes, Exported>;
    // (undocumented)
    addIntersection<T extends ReadonlyArray<IType>>(...type: IType[]): ITypeDefBuilder<Name, Generics, [
        ...JoinedTypes,
        ...JoinType<'intersection', T>
    ], Exported>;
    // Warning: (ae-forgotten-export) The symbol "JoinType" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    addUnion<T extends ReadonlyArray<IType>>(...type: T): ITypeDefBuilder<Name, Generics, [
        ...JoinedTypes,
        ...JoinType<'union', T>
    ], Exported>;
    // (undocumented)
    markExport(): ITypeDefBuilder<Name, Generics, JoinedTypes, Exported>;
    // (undocumented)
    type: 'type';
}

// @public (undocumented)
export type ITypePropertyType = IStringType | INumberType | IBooleanType | IStringLiteralType | INumberLiteralType | IBooleanLiteralType | IIdentifierType | IRawTypePropertyType;

// @public (undocumented)
export interface IUndefinedType {
    // (undocumented)
    type: 'undefined';
}

// @public (undocumented)
export interface IUnionType<T extends Readonly<IType[]> = []> {
    // (undocumented)
    definition: T;
    // (undocumented)
    extract?: ITypePropertyType[];
    // (undocumented)
    type: 'union';
}

// @public
export function keyOfExtractor<Type extends IBaseBuilderTypes, Name extends string>(builder: IBaseBuilder<Type, Name>): IRawTypePropertyType;

// @public (undocumented)
export function mapObject<T, K>(obj: Record<string, T>, transform: (value: T, key: string) => K): Record<string, K>;

// @public (undocumented)
export function nullType(): INullType;

// Warning: (ae-forgotten-export) The symbol "NumberLiterals" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export function numberTuple<T extends Readonly<number[]>>(...type: T): ITupleType<NumberLiterals<T>>;

// @public (undocumented)
export function numberType(): INumberType;

// @public (undocumented)
export function numberType<T extends number[]>(...value: T): IUnionType<NumberLiterals<T>>;

// @public (undocumented)
export function objectType<T extends IBodyType>(type: T, ...extract: ITypePropertyType[]): IObjectType<T>;

// Warning: (ae-forgotten-export) The symbol "IJsBodyValue" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "IJsObjectValue" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export function objectValue(value: IJsBodyValue): IJsObjectValue;

// Warning: (ae-forgotten-export) The symbol "IJsStringValue" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "IJsNumberValue" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "IJsBooleanValue" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export function primitiveValue(value: string | number | boolean): IJsStringValue | IJsNumberValue | IJsBooleanValue;

// @public (undocumented)
export type ProjectConfig = {
    outDir?: string;
    projectDir?: string;
};

// @public (undocumented)
export function rawType(value: string): IRawIdentifierType;

// @public (undocumented)
export function readonly<T extends IType>(type: T): IDecorationType<[T]>;

// Warning: (ae-forgotten-export) The symbol "StringLiterals" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export function stringTuple<T extends Readonly<string[]>>(...type: T): ITupleType<StringLiterals<T>>;

// @public (undocumented)
export function stringType(): IStringType;

// @public (undocumented)
export function stringType<T extends string[]>(...value: T): IUnionType<StringLiterals<T>>;

// @public (undocumented)
export function toObjectType<T extends any[]>(arr: T | undefined, transform: (value: T[number]) => {
    key: string;
    value: IBodyType[keyof IBodyType];
}): IObjectType;

// @public (undocumented)
export function tupleType<T extends readonly IType<unknown>[]>(type: T, ...extract: ITypePropertyType[]): ITupleType<T>;

// @public (undocumented)
export function typeDefBuilder<Name extends string, Generics extends Readonly<IGenericValue<string, IGenericOptions>[]> = [], JoinedTypes extends ReadonlyArray<{
    type: IType;
    joinType: 'union' | 'intersection';
}> = [], Exported extends boolean = false>(name: Name, defaultOptions?: {
    generics?: Generics;
    export: boolean;
    types?: JoinedTypes;
}): ITypeDefBuilder<Name, Generics, JoinedTypes, Exported>;

// @public (undocumented)
export function undefinedType(): IUndefinedType;

// @public (undocumented)
export function unionType<T extends ReadonlyArray<IType>>(types: T, ...extract: ITypePropertyType[]): IUnionType<T>;

// Warning: (ae-forgotten-export) The symbol "IVarObjectBuilder" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export const varObjectBuilder: (name: string, defaultValue?: {
    body: IJsBodyValue;
    decorate: 'const' | 'let' | 'var';
    export: boolean;
    type?: IType;
}) => IVarObjectBuilder;


// (No @packageDocumentation comment for this package)

```
