## API Report File for "tscgen"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public
export function arrayType<T extends IType>(type: T): IArrayType<T>;

// @public (undocumented)
export function arrowFunctionValue<Params extends IJsFunctionParamValue[]>(...params: Params): {
    addGenerics(...generics: IGenericValue[]): {
        returns: (value: IJsValue | InjectedParams<Params>, type?: IType<any> | undefined) => IJsArrowFnDefinitionValue;
    };
    returns: (value: IJsValue | InjectedParams<Params>, type?: IType<any> | undefined) => IJsArrowFnDefinitionValue;
};

// @public
export type BooleanLiterals<T extends Readonly<boolean[]>> = {
    [P in keyof T]: T[P] extends boolean ? IBooleanLiteralType<T[P]> : never;
};

// @public
export function booleanTuple<T extends Readonly<boolean[]>>(...type: T): ITupleType<BooleanLiterals<T>>;

// @public
export function booleanType(): IBooleanType;

// @public
export function booleanType<T extends boolean[]>(...value: T): IUnionType<BooleanLiterals<T>>;

// @public (undocumented)
export type BuildersToImport<T> = {
    [Key in keyof T]: T[Key] extends IEntityBuilder<IEntityBuilderTypes, string> ? IImportModuleType<T[Key]> : never;
};

// @public (undocumented)
export function callFunction(value: IJsArrowFnDefinitionValue | IJsIdentifierValue, params: IJsValue[], genericCalls?: IType[]): IJsFunctionCallValue;

// @public
export type Combine<T, K> = {
    [Key in keyof T | keyof K]: Key extends keyof K ? K[Key] : Key extends keyof T ? T[Key] : never;
};

// @public
export function combine(...builders: IBaseBuilder[]): string;

// @public
export function extract<T extends IType, K extends Readonly<IType[]>, U extends IUnionType<K>>(type: T, union: U): IDecorationType<[T, U]>;

// @public (undocumented)
export function fnParam<Key extends string>(key: Key, type: IType): IJsFunctionParamValue<Key>;

// @public (undocumented)
export function genericProperties<T extends IIdentifierType>(identifier: T, ...generics: ReadonlyArray<IType>): IGenericPropertiesType<T>;

// @public
export function genericType<T extends string>(value: T): IGenericIdentifierType<T>;

// @public (undocumented)
export function hasBodyProperty<T extends string>(key: T): (body: IBodyType) => asserts body is IBodyType & {
    [key in T]: IBodyType[keyof IBodyType];
};

// @public
export interface IArrayType<T extends IType = IType> {
    // (undocumented)
    definition: T;
    // (undocumented)
    extract?: ITypePropertyType[];
    // (undocumented)
    type: 'array';
}

// @public (undocumented)
export interface IBaseBuilder<Type extends IBaseBuilderTypes = IBaseBuilderTypes> {
    // (undocumented)
    toString(): string;
    // (undocumented)
    type: Type;
}

// @public (undocumented)
export type IBaseBuilderTypes = IEntityBuilderTypes | IImportBuilderTypes;

// @public
export interface IBodyType {
    // (undocumented)
    [key: string]: IType | [IType, boolean];
}

// @public
export interface IBooleanLiteralType<T extends boolean = boolean> {
    // (undocumented)
    definition: T;
    // (undocumented)
    type: 'boolean_literal';
}

// @public
export interface IBooleanType {
    // (undocumented)
    type: 'boolean';
}

// @public (undocumented)
export interface IDecorationType<T extends Readonly<IType[]> = Readonly<IType[]>> {
    // (undocumented)
    decorate: (...value: string[]) => string;
    // (undocumented)
    definition: T;
    // (undocumented)
    type: 'decoration';
}

// @public
export function identifierType<T extends IEntityBuilder<IEntityBuilderTypes, string>>(builder: T, ...extract: ITypePropertyType[]): IIdentifierType;

// @public
export function identifierValue<Type extends IEntityBuilderTypes, Name extends string>(builder: IEntityBuilder<Type, Name>): IJsIdentifierValue;

// @public (undocumented)
export interface IEntityBuilder<Type extends IEntityBuilderTypes = IEntityBuilderTypes, Name extends string = string> {
    // (undocumented)
    as<Identifier extends IEntityBuilderTypes>(identifier: Identifier): Identifier extends 'type' ? IGenericTypeAliasBuilder : Identifier extends 'interface' ? IGenericInterfaceBuilder : IVariableBuilder;
    // (undocumented)
    markExport(defaultExport?: boolean): IEntityBuilder<Type, Name>;
    // (undocumented)
    toString(): string;
    // (undocumented)
    type: Type;
    // (undocumented)
    varName: Name;
}

// @public (undocumented)
export type IEntityBuilderTypes = IJavascriptBuilderTypes | ITypescriptBuilderTypes;

// @public
export type IGenericIdentifierType<T extends string = string> = {
    type: 'generic_identifier';
    definition: T;
};

// @public (undocumented)
export type IGenericInterfaceBuilder = IInterfaceBuilder<string, ReadonlyArray<IGenericValue<string, IGenericOptions | undefined>>, IBodyType, boolean, IIdentifierType<IEntityBuilder<'interface', string>> | undefined>;

// @public
export type IGenericOptions = {
    extendsValue?: IType;
    defaultValue?: IType;
} | undefined;

// @public (undocumented)
export interface IGenericPropertiesType<T extends IIdentifierType = IIdentifierType> {
    // (undocumented)
    definition: T;
    // (undocumented)
    generics: ReadonlyArray<IType>;
    // (undocumented)
    type: 'generic_properties';
}

// @public (undocumented)
export type IGenericTypeAliasBuilder = ITypeAliasBuilder<string, ReadonlyArray<IGenericValue<string, IGenericOptions | undefined>>, ReadonlyArray<{
    type: IType;
    joinType: 'union' | 'intersection';
}>, boolean>;

// @public
export type IGenericValue<Name extends string = string, Options extends IGenericOptions = undefined> = {
    name: Name;
    options: Options;
};

// @public
export interface IIdentifierType<T extends IEntityBuilder<IEntityBuilderTypes, string> = IEntityBuilder<IEntityBuilderTypes, string>> {
    // (undocumented)
    definition: T;
    // (undocumented)
    extract?: ITypePropertyType[];
    // (undocumented)
    type: 'type_identifier';
}

// @public (undocumented)
export interface IImportAllModulesType<T extends string = string> {
    // (undocumented)
    type: 'import_all_modules';
    // (undocumented)
    value: T;
}

// @public (undocumented)
export interface IImportBuilder<Module extends ReadonlyArray<IImportModuleType> = ReadonlyArray<IImportModuleType>, AllModules extends string | undefined = string | undefined, DefaultImport extends string | undefined = string | undefined, Location extends string | undefined = string | undefined> extends IBaseBuilder<'import'> {
    // (undocumented)
    addAllModuleImports: <T extends string>(name: T) => IImportBuilder<Module, T, DefaultImport, Location>;
    // (undocumented)
    addDefaultImport: <T extends string>(name: T) => IImportBuilder<Module, AllModules, T, Location>;
    // (undocumented)
    addImportLocation: <T extends string>(name: T) => IImportBuilder<Module, AllModules, DefaultImport, T>;
    // (undocumented)
    addModules: <T extends ReadonlyArray<IEntityBuilder | IImportLazyType<IImportModuleType>>>(...builder: T) => IImportBuilder<[
        ...Module,
        ...BuildersToImport<T>
    ], AllModules, DefaultImport, Location>;
    // (undocumented)
    type: 'import';
}

// @public (undocumented)
export type IImportBuilderTypes = 'import';

// @public (undocumented)
export interface IImportDefaultType<T extends string = string> {
    // (undocumented)
    type: 'import_default';
    // (undocumented)
    value: T;
}

// @public (undocumented)
export interface IImportLazyType<T extends IImportType = IImportType> {
    // (undocumented)
    type: 'import_lazy';
    // (undocumented)
    value: () => T;
}

// @public (undocumented)
export interface IImportLocationType<T extends string = string> {
    // (undocumented)
    type: 'import_location';
    // (undocumented)
    value: T;
}

// @public (undocumented)
export interface IImportModuleType<T extends IEntityBuilder<IEntityBuilderTypes, string> = IEntityBuilder<IEntityBuilderTypes, string>> {
    // (undocumented)
    type: 'import_module';
    // (undocumented)
    value: T;
}

// @public (undocumented)
export type IImportType<T extends any = any> = IImportModuleType<T extends IEntityBuilder<IEntityBuilderTypes, string> ? T : IEntityBuilder<IEntityBuilderTypes, string>> | IImportLocationType<T extends string ? T : string> | IImportDefaultType<T extends string ? T : string> | IImportAllModulesType<T extends string ? T : string> | IImportLazyType<T extends IImportType ? T : IImportType>;

// @public
export interface IInterfaceBuilder<Name extends string, Generics extends Readonly<IGenericValue<string, IGenericOptions | undefined>[]>, Body extends IBodyType, Exported extends boolean, Extend extends IIdentifierType<IEntityBuilder<'interface', string>> | undefined> extends IEntityBuilder<'interface', Name> {
    addBody<T extends IBodyType>(body: T): IInterfaceBuilder<Name, Generics, Combine<Body, T>, Exported, Extend>;
    // (undocumented)
    addGeneric<N extends string, Options extends IGenericOptions = {}, T extends Readonly<IGenericValue<N, Options>> = Readonly<IGenericValue<N, Options>>>(name: N, options?: Options): IInterfaceBuilder<Name, [...Generics, T], Body, Exported, Extend>;
    // (undocumented)
    body: Body;
    extends<T extends IEntityBuilder<'interface', string>>(type: T): IInterfaceBuilder<Name, Generics, Body, Exported, IIdentifierType<T>>;
    // (undocumented)
    generics: Generics;
    markExport(defaultExport?: boolean): IInterfaceBuilder<Name, Generics, Body, true, Extend>;
    // (undocumented)
    type: 'interface';
}

// @public
export interface IIntersectionType<T extends Readonly<IType[]> = []> {
    // (undocumented)
    definition: T;
    // (undocumented)
    extract?: ITypePropertyType[];
    // (undocumented)
    type: 'intersection';
}

// @public (undocumented)
export type IJavascriptBuilderTypes = 'variable';

// @public (undocumented)
export type IJsArrayValue = IJsValue[];

// @public (undocumented)
export interface IJsArrowFnDefinitionValue {
    // (undocumented)
    type: 'arrow_function';
    // (undocumented)
    value: {
        generic?: IGenericValue[];
        returnType?: IType;
        params: IJsFunctionParamValue[];
        returnValue: IJsValue;
    };
}

// @public (undocumented)
export interface IJsBodyValue {
    // (undocumented)
    [key: string]: IJsValue;
}

// @public (undocumented)
export type IJsBooleanValue = boolean;

// @public (undocumented)
export interface IJsFunctionCallValue {
    // (undocumented)
    genericCalls?: IType[];
    // (undocumented)
    params: IJsValue[];
    // (undocumented)
    type: 'function_call';
    // (undocumented)
    value: IJsArrowFnDefinitionValue | IJsIdentifierValue;
}

// @public (undocumented)
export interface IJsFunctionParamValue<Key extends string = string> {
    // (undocumented)
    type: 'function_param';
    // (undocumented)
    value: {
        key: Key;
        type: IType;
    };
}

// @public (undocumented)
export interface IJsIdentifierValue {
    // (undocumented)
    type: 'js_identifier';
    // (undocumented)
    value: string;
}

// @public (undocumented)
export type IJsNumberValue = number;

// @public (undocumented)
export interface IJsObjectValue {
    // (undocumented)
    type: 'object';
    // (undocumented)
    value: IJsBodyValue;
}

// @public (undocumented)
export interface IJsProperties {
    // (undocumented)
    properties: IJsValue[];
    // (undocumented)
    type: 'value_properties';
    // (undocumented)
    value: IJsValue;
}

// @public (undocumented)
export type IJsStringValue = string;

// @public (undocumented)
export type IJsValue = IJsStringValue | IJsBooleanValue | IJsNumberValue | IJsArrayValue | IJsObjectValue | IJsIdentifierValue | IJsArrowFnDefinitionValue | IJsFunctionCallValue | IJsProperties | IUndefinedValue | INullValue;

// @public
export interface ILazyType<T extends IType> {
    // (undocumented)
    definition: () => T;
    // (undocumented)
    type: 'lazy_type';
}

// @public (undocumented)
export function importBuilder<Module extends ReadonlyArray<IImportModuleType> = [], AllModules extends string | undefined = undefined, DefaultImport extends string | undefined = undefined, Location extends string | undefined = undefined>(defaultOptions?: {
    modules: ReadonlyArray<IImportModuleType>;
    allModules?: AllModules;
    defaultImport?: DefaultImport;
    location?: Location;
}): IImportBuilder<Module, AllModules, DefaultImport, Location>;

// @public
export function importModuleType<T extends IEntityBuilder>(value: T): IImportModuleType;

// @public
export function interfaceBuilder<Name extends string, Generics extends Readonly<IGenericValue[]> = [], Body extends IBodyType = {}, Exported extends boolean = false, Extend extends IIdentifierType<IEntityBuilder<'interface', string>> | undefined = undefined>(interfaceName: Name, defaultOptions?: {
    generics?: Generics;
    extends?: Extend;
    body: Body;
    export: boolean;
    defaultExport: boolean;
}): IInterfaceBuilder<Name, Generics, Body, Exported, Extend>;

// @public
export function intersectionType<T extends ReadonlyArray<IType>>(...types: T): IIntersectionType<T>;

// @public
export interface INullType {
    // (undocumented)
    type: 'null';
}

// @public (undocumented)
export type INullValue = {
    type: 'null';
};

// @public
export interface INumberLiteralType<T extends number = number> {
    // (undocumented)
    definition: T;
    // (undocumented)
    type: 'number_literal';
}

// @public
export interface INumberType {
    // (undocumented)
    type: 'number';
}

// @public
export type IObjectType<T extends IBodyType = IBodyType> = {
    type: 'object';
    definition: T;
    extract?: ITypePropertyType[];
};

// @public
export type IRawIdentifierType = {
    type: 'raw_identifier';
    definition: string;
};

// @public (undocumented)
export interface IRawTypePropertyType {
    // (undocumented)
    definition: string;
    // (undocumented)
    type: 'raw_property_type';
}

// @public (undocumented)
export function isInterface(value: IEntityBuilder): asserts value is IGenericInterfaceBuilder;

// @public (undocumented)
export function isObjectType(value: IType): asserts value is IObjectType;

// @public (undocumented)
export function isRequiredProperty(value: IBodyType[keyof IBodyType]): asserts value is IType;

// @public (undocumented)
export function isSingleStringLiteral(value: IType): asserts value is IUnionType<[IStringLiteralType]>;

// @public (undocumented)
export function isStringType(value: IType): asserts value is IStringType;

// @public
export interface IStringLiteralType<T extends string = string> {
    // (undocumented)
    definition: T;
    // (undocumented)
    type: 'string_literal';
}

// @public
export interface IStringType {
    // (undocumented)
    type: 'string';
}

// @public (undocumented)
export function isTypeAlias(value: IEntityBuilder): asserts value is IGenericTypeAliasBuilder;

// @public (undocumented)
export function isUndefinedType(value: IBodyType[keyof IBodyType]): asserts value is IUndefinedType;

// @public
export interface ITupleType<T extends ReadonlyArray<IType> = ReadonlyArray<IType>> {
    // (undocumented)
    definition: T;
    // (undocumented)
    extract?: ITypePropertyType[];
    // (undocumented)
    type: 'tuple';
}

// @public
export type IType<T extends any = any> = IStringType | INumberType | IBooleanType | IUndefinedType | INullType | IIdentifierType<T extends IEntityBuilder<'type' | 'interface', string> ? T : IEntityBuilder<'type' | 'interface', string>> | IArrayType<T extends IType ? T : IType> | IObjectType<T extends IBodyType ? T : IBodyType> | IUnionType<T extends Readonly<IType[]> ? T : Readonly<IType[]>> | IIntersectionType<T extends Readonly<IType[]> ? T : Readonly<IType[]>> | IStringLiteralType<T extends string ? T : string> | INumberLiteralType<T extends number ? T : number> | IBooleanLiteralType<T extends boolean ? T : boolean> | ITupleType<T extends Readonly<IType[]> ? T : Readonly<IType[]>> | IDecorationType<T extends Readonly<IType[]> ? T : Readonly<IType[]>> | IGenericIdentifierType<T extends string ? T : string> | IGenericPropertiesType<T extends IIdentifierType ? T : IIdentifierType> | ITypeProperties<T extends IType ? T : IType> | IRawIdentifierType | ILazyType<T extends IType ? T : IType>;

// @public (undocumented)
export interface ITypeAliasBuilder<Name extends string, Generics extends Readonly<IGenericValue<string, IGenericOptions>[]>, JoinedTypes extends ReadonlyArray<{
    type: IType;
    joinType: 'union' | 'intersection';
}>, Exported extends boolean> extends IEntityBuilder<'type', Name> {
    // (undocumented)
    addGeneric<N extends string, Options extends IGenericOptions = {}, T extends Readonly<IGenericValue<N, Options>> = Readonly<IGenericValue<N, Options>>>(name: N, options?: Options): ITypeAliasBuilder<Name, [...Generics, T], JoinedTypes, Exported>;
    // (undocumented)
    addIntersection<T extends ReadonlyArray<IType>>(...type: IType[]): ITypeAliasBuilder<Name, Generics, [
        ...JoinedTypes,
        ...JoinType<'intersection', T>
    ], Exported>;
    // (undocumented)
    addUnion<T extends ReadonlyArray<IType>>(...type: T): ITypeAliasBuilder<Name, Generics, [
        ...JoinedTypes,
        ...JoinType<'union', T>
    ], Exported>;
    // (undocumented)
    markExport(): ITypeAliasBuilder<Name, Generics, JoinedTypes, Exported>;
    // (undocumented)
    type: 'type';
}

// @public (undocumented)
export interface ITypeProperties<T extends IType = IType> {
    // (undocumented)
    definition: T;
    // (undocumented)
    properties: ReadonlyArray<IType>;
    // (undocumented)
    type: 'type_properties';
}

// @public (undocumented)
export type ITypePropertyType = IStringType | INumberType | IBooleanType | IStringLiteralType | INumberLiteralType | IBooleanLiteralType | IIdentifierType | IRawTypePropertyType;

// @public (undocumented)
export type ITypescriptBuilderTypes = 'type' | 'interface';

// @public
export interface IUndefinedType {
    // (undocumented)
    type: 'undefined';
}

// @public (undocumented)
export type IUndefinedValue = {
    type: 'undefined';
};

// @public
export interface IUnionType<T extends Readonly<IType[]> = Readonly<IType[]>> {
    // (undocumented)
    definition: T;
    // (undocumented)
    extract?: ITypePropertyType[];
    // (undocumented)
    type: 'union';
}

// @public (undocumented)
export interface IVariableBuilder extends IEntityBuilder<'variable', string> {
    // (undocumented)
    addTypeAlias(typeDefinition: IType): IVariableBuilder;
    // (undocumented)
    markExport(defaultExport?: boolean): IVariableBuilder;
    // (undocumented)
    setAssignment(body: IJsValue): IVariableBuilder;
    // (undocumented)
    setLevel(level: 'const' | 'let' | 'var'): IVariableBuilder;
    // (undocumented)
    type: 'variable';
}

// @public (undocumented)
export type JoinType<K extends 'union' | 'intersection', T> = {
    [Key in keyof T]: {
        joinType: K;
        type: T[Key];
    };
};

// @public
export function keyOfExtractor<Type extends IEntityBuilderTypes, Name extends string>(builder: IEntityBuilder<Type, Name>): IRawTypePropertyType;

// @public
export function lazyImportType<T extends IImportType>(value: () => T): IImportLazyType<T>;

// @public
export function lazyType<T extends IType>(value: () => T): ILazyType<T>;

// @public
export function mapObject<T, K>(obj: Record<string, T>, transform: (value: T, key: string) => K): Record<string, K>;

// @public
export function mapObjectPromise<T, K>(obj: Record<string, T>, transform: (value: T, key: string) => Promiseable<K>): Promise<Record<string, K>>;

// @public
export function nullType(): INullType;

// @public (undocumented)
export function nullValue(): INullValue;

// @public
export type NumberLiterals<T extends Readonly<number[]>> = {
    [P in keyof T]: T[P] extends number ? INumberLiteralType<T[P]> : never;
};

// @public
export function numberTuple<T extends Readonly<number[]>>(...type: T): ITupleType<NumberLiterals<T>>;

// @public
export function numberType(): INumberType;

// @public
export function numberType<T extends number[]>(...value: T): IUnionType<NumberLiterals<T>>;

// @public
export function objectType<T extends IBodyType>(type: T): IObjectType<T>;

// @public
export function objectValue(value: IJsBodyValue): IJsObjectValue;

// @public (undocumented)
export type Promiseable<T> = T | Promise<T>;

// @public
export function rawType(value: string): IRawIdentifierType;

// @public
export function readonly<T extends IType>(type: T): IDecorationType<[T]>;

// @public
export type StringLiterals<T extends Readonly<string[]>> = {
    [P in keyof T]: T[P] extends string ? IStringLiteralType<T[P]> : never;
};

// @public
export function stringTuple<T extends Readonly<string[]>>(...type: T): ITupleType<StringLiterals<T>>;

// @public
export function stringType(): IStringType;

// @public
export function stringType<T extends string[]>(...value: T): IUnionType<StringLiterals<T>>;

// @public
export function toObjectType<T extends unknown[]>(arr: T | undefined, transform: (value: T[number]) => {
    key: string;
    value: IBodyType[keyof IBodyType];
} | undefined): IObjectType;

// Warning: (ae-forgotten-export) The symbol "AssertReturn" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export function tryPipe<T>(value: T): AssertReturn<T>;

// @public
export function tupleType<T extends readonly IType<unknown>[]>(...type: T): ITupleType<T>;

// @public (undocumented)
export function typeAliasBuilder<Name extends string, Generics extends Readonly<IGenericValue<string, IGenericOptions>[]> = [], JoinedTypes extends ReadonlyArray<{
    type: IType;
    joinType: 'union' | 'intersection';
}> = [], Exported extends boolean = false>(name: Name, defaultOptions?: {
    generics?: Generics;
    export: boolean;
    types?: JoinedTypes;
}): ITypeAliasBuilder<Name, Generics, JoinedTypes, Exported>;

// @public (undocumented)
export function typeProperties<T extends IType>(identifier: T, ...properties: ReadonlyArray<IType>): ITypeProperties<T>;

// @public
export function undefinedType(): IUndefinedType;

// @public (undocumented)
export function undefinedValue(): IUndefinedValue;

// @public
export function unionType<T extends ReadonlyArray<IType>>(...types: T): IUnionType<T>;

// @public (undocumented)
export type Unpromise<T> = T extends Promise<infer U> ? U : never;

// @public (undocumented)
export function valueProperties(value: IJsValue, ...properties: IJsValue[]): IJsProperties;

// @public (undocumented)
export const variableBuilder: (name: string, defaultValue?: {
    body?: IJsValue;
    decorate: 'const' | 'let' | 'var';
    export: boolean;
    type?: IType;
    defaultExport: boolean;
}) => IVariableBuilder;


// Warnings were encountered during analysis:
//
// src/javascript/definitions.ts:104:9 - (ae-forgotten-export) The symbol "InjectedParams" needs to be exported by the entry point index.d.ts

// (No @packageDocumentation comment for this package)

```
