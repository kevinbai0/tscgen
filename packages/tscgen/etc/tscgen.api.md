## API Report File for "tscgen"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public (undocumented)
export function arrayType<T extends IType>(type: T, ...extract: ITypePropertyType[]): IArrayType<T>;

// @public (undocumented)
export type BooleanLiterals<T extends Readonly<boolean[]>> = {
    [P in keyof T]: T[P] extends boolean ? IBooleanLiteralType<T[P]> : never;
};

// @public (undocumented)
export function booleanTuple<T extends Readonly<boolean[]>>(...type: T): ITupleType<BooleanLiterals<T>>;

// @public (undocumented)
export function booleanType(): IBooleanType;

// @public (undocumented)
export function booleanType<T extends boolean[]>(...value: T): IUnionType<BooleanLiterals<T>>;

// @public (undocumented)
export type BuildersToImport<T> = {
    [Key in keyof T]: T[Key] extends IEntityBuilder<IEntityBuilderTypes, string> ? IImportModuleType<T[Key]> : never;
};

// @public (undocumented)
export type Combine<T, K> = {
    [Key in keyof T | keyof K]: Key extends keyof K ? K[Key] : Key extends keyof T ? T[Key] : never;
};

// @public
export function combine(...builders: IBaseBuilder[]): string;

// @public (undocumented)
export const createFormatter: (pathToFile: string) => (text: string) => Promise<string>;

// @public (undocumented)
export function extract<T extends IType, K extends Readonly<IType[]>, U extends IUnionType<K>>(type: T, union: U): IDecorationType<[T, U]>;

// @public (undocumented)
export type Formatter = ReturnType<typeof createFormatter>;

// @public (undocumented)
export function genericType<T extends string>(value: T): IGenericIdentifierType<T>;

// @public
export interface IArrayType<T extends IType = IType> {
    // (undocumented)
    definition: T;
    // (undocumented)
    extract?: ITypePropertyType[];
    // (undocumented)
    type: 'array';
}

// @public (undocumented)
export interface IBaseBuilder<Type extends IBaseBuilderTypes = IBaseBuilderTypes> {
    // (undocumented)
    toString(): string;
    // (undocumented)
    type: Type;
}

// @public (undocumented)
export type IBaseBuilderTypes = IEntityBuilderTypes | IImportBuilderTypes;

// @public
export interface IBodyType {
    // (undocumented)
    [key: string]: IType | [IType, boolean];
}

// @public
export interface IBooleanLiteralType<T extends boolean = boolean> {
    // (undocumented)
    definition: T;
    // (undocumented)
    type: 'boolean_literal';
}

// @public
export interface IBooleanType {
    // (undocumented)
    type: 'boolean';
}

// @public (undocumented)
export interface IDecorationType<T extends Readonly<IType[]> = Readonly<IType[]>> {
    // (undocumented)
    decorate: (...value: string[]) => string;
    // (undocumented)
    definition: T;
    // (undocumented)
    type: 'decoration';
}

// @public (undocumented)
export function identifierType<T extends IEntityBuilder<IEntityBuilderTypes, string>>(builder: T, ...extract: ITypePropertyType[]): IIdentifierType;

// @public (undocumented)
export function identifierValue<Type extends IEntityBuilderTypes, Name extends string>(builder: IEntityBuilder<Type, Name>): IJsIdentifierValue;

// @public (undocumented)
export interface IEntityBuilder<Type extends IEntityBuilderTypes = IEntityBuilderTypes, Name extends string = string> {
    // (undocumented)
    markExport(): IEntityBuilder<Type, Name>;
    // (undocumented)
    toString(): string;
    // (undocumented)
    type: Type;
    // (undocumented)
    varName: Name;
}

// @public (undocumented)
export type IEntityBuilderTypes = IJavascriptBuilderTypes | ITypescriptBuilderTypes;

// @public
export type IGenericIdentifierType<T extends string = string> = {
    type: 'generic_identifier';
    definition: T;
};

// @public (undocumented)
export type IGenericInterfaceBuilder = IInterfaceBuilder<string, ReadonlyArray<IGenericValue<string, IGenericOptions | undefined>>, IBodyType, boolean, IIdentifierType<IEntityBuilder<'interface', string>> | undefined>;

// @public
export type IGenericOptions = {
    extendsValue?: IType;
    defaultValue?: IType;
} | undefined;

// @public (undocumented)
export type IGenericTypeDefBuilder = ITypeDefBuilder<string, ReadonlyArray<IGenericValue<string, IGenericOptions | undefined>>, ReadonlyArray<{
    type: IType;
    joinType: 'union' | 'intersection';
}>, boolean>;

// @public
export type IGenericValue<Name extends string = string, Options extends IGenericOptions = undefined> = {
    name: Name;
    options: Options;
};

// @public
export interface IIdentifierType<T extends IEntityBuilder<IEntityBuilderTypes, string> = IEntityBuilder<IEntityBuilderTypes, string>> {
    // (undocumented)
    definition: T;
    // (undocumented)
    extract?: ITypePropertyType[];
    // (undocumented)
    type: 'identifier';
}

// @public (undocumented)
export interface IImportAllModulesType<T extends string = string> {
    // (undocumented)
    type: 'import_all_modules';
    // (undocumented)
    value: T;
}

// @public (undocumented)
export interface IImportBuilder<Module extends ReadonlyArray<IImportModuleType> = ReadonlyArray<IImportModuleType>, AllModules extends string | undefined = string | undefined, DefaultImport extends string | undefined = string | undefined, Location extends string | undefined = string | undefined> extends IBaseBuilder<'import'> {
    // (undocumented)
    addAllModuleImports: <T extends string>(name: T) => IImportBuilder<Module, T, DefaultImport, Location>;
    // (undocumented)
    addDefaultImport: <T extends string>(name: T) => IImportBuilder<Module, AllModules, T, Location>;
    // (undocumented)
    addImportLocation: <T extends string>(name: T) => IImportBuilder<Module, AllModules, DefaultImport, T>;
    // (undocumented)
    addModules: <T extends ReadonlyArray<IEntityBuilder | IImportLazyType<IImportModuleType>>>(...builder: T) => IImportBuilder<[
        ...Module,
        ...BuildersToImport<T>
    ], AllModules, DefaultImport, Location>;
    // (undocumented)
    type: 'import';
}

// @public (undocumented)
export type IImportBuilderTypes = 'import';

// @public (undocumented)
export interface IImportDefaultType<T extends string = string> {
    // (undocumented)
    type: 'import_default';
    // (undocumented)
    value: T;
}

// @public (undocumented)
export interface IImportLazyType<T extends IImportType = IImportType> {
    // (undocumented)
    type: 'import_lazy';
    // (undocumented)
    value: () => T;
}

// @public (undocumented)
export interface IImportLocationType<T extends string = string> {
    // (undocumented)
    type: 'import_location';
    // (undocumented)
    value: T;
}

// @public (undocumented)
export interface IImportModuleType<T extends IEntityBuilder<IEntityBuilderTypes, string> = IEntityBuilder<IEntityBuilderTypes, string>> {
    // (undocumented)
    type: 'import_module';
    // (undocumented)
    value: T;
}

// @public (undocumented)
export type IImportType<T extends any = any> = IImportModuleType<T extends IEntityBuilder<IEntityBuilderTypes, string> ? T : IEntityBuilder<IEntityBuilderTypes, string>> | IImportLocationType<T extends string ? T : string> | IImportDefaultType<T extends string ? T : string> | IImportAllModulesType<T extends string ? T : string> | IImportLazyType<T extends IImportType ? T : IImportType>;

// @public
export interface IInterfaceBuilder<Name extends string, Generics extends Readonly<IGenericValue<string, IGenericOptions | undefined>[]>, Body extends IBodyType, Exported extends boolean, Extend extends IIdentifierType<IEntityBuilder<'interface', string>> | undefined> extends IEntityBuilder<'interface', Name> {
    addBody<T extends IBodyType>(body: T): IInterfaceBuilder<Name, Generics, Combine<Body, T>, Exported, Extend>;
    // (undocumented)
    addGeneric<N extends string, Options extends IGenericOptions = {}, T extends Readonly<IGenericValue<N, Options>> = Readonly<IGenericValue<N, Options>>>(name: N, options?: Options): IInterfaceBuilder<Name, [...Generics, T], Body, Exported, Extend>;
    // (undocumented)
    body: Body;
    extends<T extends IEntityBuilder<'interface', string>>(type: T): IInterfaceBuilder<Name, Generics, Body, Exported, IIdentifierType<T>>;
    // (undocumented)
    generics: Generics;
    markExport(): IInterfaceBuilder<Name, Generics, Body, true, Extend>;
    // (undocumented)
    type: 'interface';
}

// @public
export interface IIntersectionType<T extends Readonly<IType[]> = []> {
    // (undocumented)
    definition: T;
    // (undocumented)
    extract?: ITypePropertyType[];
    // (undocumented)
    type: 'intersection';
}

// @public (undocumented)
export type IJavascriptBuilderTypes = 'object';

// @public (undocumented)
export type IJsArrayValue = IJsValue[];

// @public (undocumented)
export interface IJsBodyValue {
    // (undocumented)
    [key: string]: IJsValue;
}

// @public (undocumented)
export type IJsBooleanValue = boolean;

// @public (undocumented)
export interface IJsIdentifierValue {
    // (undocumented)
    type: 'identifier';
    // (undocumented)
    value: string;
}

// @public (undocumented)
export type IJsNumberValue = number;

// @public (undocumented)
export interface IJsObjectValue {
    // (undocumented)
    type: 'object';
    // (undocumented)
    value: IJsBodyValue;
}

// @public (undocumented)
export type IJsStringValue = string;

// @public (undocumented)
export type IJsValue = IJsStringValue | IJsBooleanValue | IJsNumberValue | IJsArrayValue | IJsObjectValue | IJsIdentifierValue;

// @public
export interface ILazyType<T extends IType> {
    // (undocumented)
    definition: () => T;
    // (undocumented)
    type: 'lazy_type';
}

// @public (undocumented)
export function importBuilder<Module extends ReadonlyArray<IImportModuleType> = [], AllModules extends string | undefined = undefined, DefaultImport extends string | undefined = undefined, Location extends string | undefined = undefined>(defaultOptions?: {
    modules: ReadonlyArray<IImportModuleType>;
    allModules?: AllModules;
    defaultImport?: DefaultImport;
    location?: Location;
}): IImportBuilder<Module, AllModules, DefaultImport, Location>;

// @public (undocumented)
export function importModuleType<T extends IEntityBuilder>(value: T): IImportModuleType;

// @public (undocumented)
export function interfaceBuilder<Name extends string, Generics extends Readonly<IGenericValue[]> = [], Body extends IBodyType = {}, Exported extends boolean = false, Extend extends IIdentifierType<IEntityBuilder<'interface', string>> | undefined = undefined>(interfaceName: Name, defaultOptions?: {
    generics?: Generics;
    extends?: Extend;
    body: Body;
    export: boolean;
}): IInterfaceBuilder<Name, Generics, Body, Exported, Extend>;

// @public (undocumented)
export function intersectionType<T extends ReadonlyArray<IType>>(types: T, ...extract: ITypePropertyType[]): IIntersectionType<T>;

// @public
export interface INullType {
    // (undocumented)
    type: 'null';
}

// @public
export interface INumberLiteralType<T extends number = number> {
    // (undocumented)
    definition: T;
    // (undocumented)
    type: 'number_literal';
}

// @public
export interface INumberType {
    // (undocumented)
    type: 'number';
}

// @public
export type IObjectType<T extends IBodyType = IBodyType> = {
    type: 'object';
    definition: T;
    extract?: ITypePropertyType[];
};

// @public
export type IRawIdentifierType = {
    type: 'raw_identifier';
    definition: string;
};

// @public (undocumented)
export interface IRawTypePropertyType {
    // (undocumented)
    definition: string;
    // (undocumented)
    type: 'raw_property_type';
}

// @public
export interface IStringLiteralType<T extends string = string> {
    // (undocumented)
    definition: T;
    // (undocumented)
    type: 'string_literal';
}

// @public
export interface IStringType {
    // (undocumented)
    type: 'string';
}

// @public
export interface ITupleType<T extends ReadonlyArray<IType> = ReadonlyArray<IType>> {
    // (undocumented)
    definition: T;
    // (undocumented)
    extract?: ITypePropertyType[];
    // (undocumented)
    type: 'tuple';
}

// @public
export type IType<T extends any = any> = IStringType | INumberType | IBooleanType | IUndefinedType | INullType | IIdentifierType<T extends IEntityBuilder<'type' | 'interface', string> ? T : IEntityBuilder<'type' | 'interface', string>> | IArrayType<T extends IType ? T : IType> | IObjectType<T extends IBodyType ? T : IBodyType> | IUnionType<T extends Readonly<IType[]> ? T : Readonly<IType[]>> | IIntersectionType<T extends Readonly<IType[]> ? T : Readonly<IType[]>> | IStringLiteralType<T extends string ? T : string> | INumberLiteralType<T extends number ? T : number> | IBooleanLiteralType<T extends boolean ? T : boolean> | ITupleType<T extends Readonly<IType[]> ? T : Readonly<IType[]>> | IDecorationType<T extends Readonly<IType[]> ? T : Readonly<IType[]>> | IGenericIdentifierType<T extends string ? T : string> | IRawIdentifierType | ILazyType<T extends IType ? T : IType>;

// @public (undocumented)
export interface ITypeDefBuilder<Name extends string, Generics extends Readonly<IGenericValue<string, IGenericOptions>[]>, JoinedTypes extends ReadonlyArray<{
    type: IType;
    joinType: 'union' | 'intersection';
}>, Exported extends boolean> extends IEntityBuilder<'type', Name> {
    // (undocumented)
    addGeneric<N extends string, Options extends IGenericOptions = {}, T extends Readonly<IGenericValue<N, Options>> = Readonly<IGenericValue<N, Options>>>(name: N, options?: Options): ITypeDefBuilder<Name, [...Generics, T], JoinedTypes, Exported>;
    // (undocumented)
    addIntersection<T extends ReadonlyArray<IType>>(...type: IType[]): ITypeDefBuilder<Name, Generics, [
        ...JoinedTypes,
        ...JoinType<'intersection', T>
    ], Exported>;
    // (undocumented)
    addUnion<T extends ReadonlyArray<IType>>(...type: T): ITypeDefBuilder<Name, Generics, [
        ...JoinedTypes,
        ...JoinType<'union', T>
    ], Exported>;
    // (undocumented)
    markExport(): ITypeDefBuilder<Name, Generics, JoinedTypes, Exported>;
    // (undocumented)
    type: 'type';
}

// @public (undocumented)
export type ITypePropertyType = IStringType | INumberType | IBooleanType | IStringLiteralType | INumberLiteralType | IBooleanLiteralType | IIdentifierType | IRawTypePropertyType;

// @public (undocumented)
export type ITypescriptBuilderTypes = 'type' | 'interface';

// @public
export interface IUndefinedType {
    // (undocumented)
    type: 'undefined';
}

// @public
export interface IUnionType<T extends Readonly<IType[]> = []> {
    // (undocumented)
    definition: T;
    // (undocumented)
    extract?: ITypePropertyType[];
    // (undocumented)
    type: 'union';
}

// @public (undocumented)
export interface IVarObjectBuilder extends IEntityBuilder<'object', string> {
    // (undocumented)
    addBody(body: IJsBodyValue): IVarObjectBuilder;
    // (undocumented)
    addTypeDef(typeDefinition: IType): IVarObjectBuilder;
    // (undocumented)
    markExport(): IVarObjectBuilder;
    // (undocumented)
    setLevel(level: 'const' | 'let' | 'var'): IVarObjectBuilder;
    // (undocumented)
    type: 'object';
}

// @public (undocumented)
export type JoinType<K extends 'union' | 'intersection', T> = {
    [Key in keyof T]: {
        joinType: K;
        type: T[Key];
    };
};

// @public
export function keyOfExtractor<Type extends IEntityBuilderTypes, Name extends string>(builder: IEntityBuilder<Type, Name>): IRawTypePropertyType;

// @public (undocumented)
export function lazyImportType<T extends IImportType>(value: () => T): IImportLazyType<T>;

// @public (undocumented)
export function lazyType<T extends IType>(value: () => T): ILazyType<T>;

// @public
export function mapObject<T, K>(obj: Record<string, T>, transform: (value: T, key: string) => K): Record<string, K>;

// @public
export function mapObjectPromise<T, K>(obj: Record<string, T>, transform: (value: T, key: string) => Promiseable<K>): Promise<Record<string, K>>;

// @public (undocumented)
export function nullType(): INullType;

// @public (undocumented)
export type NumberLiterals<T extends Readonly<number[]>> = {
    [P in keyof T]: T[P] extends number ? INumberLiteralType<T[P]> : never;
};

// @public (undocumented)
export function numberTuple<T extends Readonly<number[]>>(...type: T): ITupleType<NumberLiterals<T>>;

// @public (undocumented)
export function numberType(): INumberType;

// @public (undocumented)
export function numberType<T extends number[]>(...value: T): IUnionType<NumberLiterals<T>>;

// @public (undocumented)
export function objectType<T extends IBodyType>(type: T, ...extract: ITypePropertyType[]): IObjectType<T>;

// @public (undocumented)
export function objectValue(value: IJsBodyValue): IJsObjectValue;

// @public (undocumented)
export type Promiseable<T> = T | Promise<T>;

// @public (undocumented)
export function rawType(value: string): IRawIdentifierType;

// @public (undocumented)
export function readonly<T extends IType>(type: T): IDecorationType<[T]>;

// @public (undocumented)
export type StringLiterals<T extends Readonly<string[]>> = {
    [P in keyof T]: T[P] extends string ? IStringLiteralType<T[P]> : never;
};

// @public (undocumented)
export function stringTuple<T extends Readonly<string[]>>(...type: T): ITupleType<StringLiterals<T>>;

// @public (undocumented)
export function stringType(): IStringType;

// @public (undocumented)
export function stringType<T extends string[]>(...value: T): IUnionType<StringLiterals<T>>;

// @public (undocumented)
export function toObjectType<T extends unknown[]>(arr: T | undefined, transform: (value: T[number]) => {
    key: string;
    value: IBodyType[keyof IBodyType];
} | undefined): IObjectType;

// @public (undocumented)
export function tupleType<T extends readonly IType<unknown>[]>(type: T, ...extract: ITypePropertyType[]): ITupleType<T>;

// @public (undocumented)
export function typeDefBuilder<Name extends string, Generics extends Readonly<IGenericValue<string, IGenericOptions>[]> = [], JoinedTypes extends ReadonlyArray<{
    type: IType;
    joinType: 'union' | 'intersection';
}> = [], Exported extends boolean = false>(name: Name, defaultOptions?: {
    generics?: Generics;
    export: boolean;
    types?: JoinedTypes;
}): ITypeDefBuilder<Name, Generics, JoinedTypes, Exported>;

// @public (undocumented)
export function undefinedType(): IUndefinedType;

// @public (undocumented)
export function unionType<T extends ReadonlyArray<IType>>(types: T, ...extract: ITypePropertyType[]): IUnionType<T>;

// @public (undocumented)
export type Unpromise<T> = T extends Promise<infer U> ? U : never;

// @public (undocumented)
export const varObjectBuilder: (name: string, defaultValue?: {
    body: IJsBodyValue;
    decorate: 'const' | 'let' | 'var';
    export: boolean;
    type?: IType;
}) => IVarObjectBuilder;


// (No @packageDocumentation comment for this package)

```
